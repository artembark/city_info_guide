// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'thread_dto.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

ThreadDTO _$ThreadDTOFromJson(Map<String, dynamic> json) {
  return _ThreadDTO.fromJson(json);
}

/// @nodoc
mixin _$ThreadDTO {
  String? get uid => throw _privateConstructorUsedError;
  String? get title => throw _privateConstructorUsedError;
  String? get number => throw _privateConstructorUsedError;
  String? get shortTitle => throw _privateConstructorUsedError;
  String? get threadMethodLink => throw _privateConstructorUsedError;
  dynamic get carrier => throw _privateConstructorUsedError;
  String? get transportType => throw _privateConstructorUsedError;
  dynamic get vehicle => throw _privateConstructorUsedError;
  TransportSubtypeDTO? get transportSubtype =>
      throw _privateConstructorUsedError;
  dynamic get expressType => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ThreadDTOCopyWith<ThreadDTO> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ThreadDTOCopyWith<$Res> {
  factory $ThreadDTOCopyWith(ThreadDTO value, $Res Function(ThreadDTO) then) =
      _$ThreadDTOCopyWithImpl<$Res>;
  $Res call(
      {String? uid,
      String? title,
      String? number,
      String? shortTitle,
      String? threadMethodLink,
      dynamic carrier,
      String? transportType,
      dynamic vehicle,
      TransportSubtypeDTO? transportSubtype,
      dynamic expressType});

  $TransportSubtypeDTOCopyWith<$Res>? get transportSubtype;
}

/// @nodoc
class _$ThreadDTOCopyWithImpl<$Res> implements $ThreadDTOCopyWith<$Res> {
  _$ThreadDTOCopyWithImpl(this._value, this._then);

  final ThreadDTO _value;
  // ignore: unused_field
  final $Res Function(ThreadDTO) _then;

  @override
  $Res call({
    Object? uid = freezed,
    Object? title = freezed,
    Object? number = freezed,
    Object? shortTitle = freezed,
    Object? threadMethodLink = freezed,
    Object? carrier = freezed,
    Object? transportType = freezed,
    Object? vehicle = freezed,
    Object? transportSubtype = freezed,
    Object? expressType = freezed,
  }) {
    return _then(_value.copyWith(
      uid: uid == freezed
          ? _value.uid
          : uid // ignore: cast_nullable_to_non_nullable
              as String?,
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      number: number == freezed
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      shortTitle: shortTitle == freezed
          ? _value.shortTitle
          : shortTitle // ignore: cast_nullable_to_non_nullable
              as String?,
      threadMethodLink: threadMethodLink == freezed
          ? _value.threadMethodLink
          : threadMethodLink // ignore: cast_nullable_to_non_nullable
              as String?,
      carrier: carrier == freezed
          ? _value.carrier
          : carrier // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transportType: transportType == freezed
          ? _value.transportType
          : transportType // ignore: cast_nullable_to_non_nullable
              as String?,
      vehicle: vehicle == freezed
          ? _value.vehicle
          : vehicle // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transportSubtype: transportSubtype == freezed
          ? _value.transportSubtype
          : transportSubtype // ignore: cast_nullable_to_non_nullable
              as TransportSubtypeDTO?,
      expressType: expressType == freezed
          ? _value.expressType
          : expressType // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }

  @override
  $TransportSubtypeDTOCopyWith<$Res>? get transportSubtype {
    if (_value.transportSubtype == null) {
      return null;
    }

    return $TransportSubtypeDTOCopyWith<$Res>(_value.transportSubtype!,
        (value) {
      return _then(_value.copyWith(transportSubtype: value));
    });
  }
}

/// @nodoc
abstract class _$$_ThreadDTOCopyWith<$Res> implements $ThreadDTOCopyWith<$Res> {
  factory _$$_ThreadDTOCopyWith(
          _$_ThreadDTO value, $Res Function(_$_ThreadDTO) then) =
      __$$_ThreadDTOCopyWithImpl<$Res>;
  @override
  $Res call(
      {String? uid,
      String? title,
      String? number,
      String? shortTitle,
      String? threadMethodLink,
      dynamic carrier,
      String? transportType,
      dynamic vehicle,
      TransportSubtypeDTO? transportSubtype,
      dynamic expressType});

  @override
  $TransportSubtypeDTOCopyWith<$Res>? get transportSubtype;
}

/// @nodoc
class __$$_ThreadDTOCopyWithImpl<$Res> extends _$ThreadDTOCopyWithImpl<$Res>
    implements _$$_ThreadDTOCopyWith<$Res> {
  __$$_ThreadDTOCopyWithImpl(
      _$_ThreadDTO _value, $Res Function(_$_ThreadDTO) _then)
      : super(_value, (v) => _then(v as _$_ThreadDTO));

  @override
  _$_ThreadDTO get _value => super._value as _$_ThreadDTO;

  @override
  $Res call({
    Object? uid = freezed,
    Object? title = freezed,
    Object? number = freezed,
    Object? shortTitle = freezed,
    Object? threadMethodLink = freezed,
    Object? carrier = freezed,
    Object? transportType = freezed,
    Object? vehicle = freezed,
    Object? transportSubtype = freezed,
    Object? expressType = freezed,
  }) {
    return _then(_$_ThreadDTO(
      uid: uid == freezed
          ? _value.uid
          : uid // ignore: cast_nullable_to_non_nullable
              as String?,
      title: title == freezed
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String?,
      number: number == freezed
          ? _value.number
          : number // ignore: cast_nullable_to_non_nullable
              as String?,
      shortTitle: shortTitle == freezed
          ? _value.shortTitle
          : shortTitle // ignore: cast_nullable_to_non_nullable
              as String?,
      threadMethodLink: threadMethodLink == freezed
          ? _value.threadMethodLink
          : threadMethodLink // ignore: cast_nullable_to_non_nullable
              as String?,
      carrier: carrier == freezed
          ? _value.carrier
          : carrier // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transportType: transportType == freezed
          ? _value.transportType
          : transportType // ignore: cast_nullable_to_non_nullable
              as String?,
      vehicle: vehicle == freezed
          ? _value.vehicle
          : vehicle // ignore: cast_nullable_to_non_nullable
              as dynamic,
      transportSubtype: transportSubtype == freezed
          ? _value.transportSubtype
          : transportSubtype // ignore: cast_nullable_to_non_nullable
              as TransportSubtypeDTO?,
      expressType: expressType == freezed
          ? _value.expressType
          : expressType // ignore: cast_nullable_to_non_nullable
              as dynamic,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ThreadDTO extends _ThreadDTO {
  const _$_ThreadDTO(
      {this.uid,
      this.title,
      this.number,
      this.shortTitle,
      this.threadMethodLink,
      this.carrier,
      this.transportType,
      this.vehicle,
      this.transportSubtype,
      this.expressType})
      : super._();

  factory _$_ThreadDTO.fromJson(Map<String, dynamic> json) =>
      _$$_ThreadDTOFromJson(json);

  @override
  final String? uid;
  @override
  final String? title;
  @override
  final String? number;
  @override
  final String? shortTitle;
  @override
  final String? threadMethodLink;
  @override
  final dynamic carrier;
  @override
  final String? transportType;
  @override
  final dynamic vehicle;
  @override
  final TransportSubtypeDTO? transportSubtype;
  @override
  final dynamic expressType;

  @override
  String toString() {
    return 'ThreadDTO(uid: $uid, title: $title, number: $number, shortTitle: $shortTitle, threadMethodLink: $threadMethodLink, carrier: $carrier, transportType: $transportType, vehicle: $vehicle, transportSubtype: $transportSubtype, expressType: $expressType)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ThreadDTO &&
            const DeepCollectionEquality().equals(other.uid, uid) &&
            const DeepCollectionEquality().equals(other.title, title) &&
            const DeepCollectionEquality().equals(other.number, number) &&
            const DeepCollectionEquality()
                .equals(other.shortTitle, shortTitle) &&
            const DeepCollectionEquality()
                .equals(other.threadMethodLink, threadMethodLink) &&
            const DeepCollectionEquality().equals(other.carrier, carrier) &&
            const DeepCollectionEquality()
                .equals(other.transportType, transportType) &&
            const DeepCollectionEquality().equals(other.vehicle, vehicle) &&
            const DeepCollectionEquality()
                .equals(other.transportSubtype, transportSubtype) &&
            const DeepCollectionEquality()
                .equals(other.expressType, expressType));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(uid),
      const DeepCollectionEquality().hash(title),
      const DeepCollectionEquality().hash(number),
      const DeepCollectionEquality().hash(shortTitle),
      const DeepCollectionEquality().hash(threadMethodLink),
      const DeepCollectionEquality().hash(carrier),
      const DeepCollectionEquality().hash(transportType),
      const DeepCollectionEquality().hash(vehicle),
      const DeepCollectionEquality().hash(transportSubtype),
      const DeepCollectionEquality().hash(expressType));

  @JsonKey(ignore: true)
  @override
  _$$_ThreadDTOCopyWith<_$_ThreadDTO> get copyWith =>
      __$$_ThreadDTOCopyWithImpl<_$_ThreadDTO>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ThreadDTOToJson(this);
  }
}

abstract class _ThreadDTO extends ThreadDTO {
  const factory _ThreadDTO(
      {final String? uid,
      final String? title,
      final String? number,
      final String? shortTitle,
      final String? threadMethodLink,
      final dynamic carrier,
      final String? transportType,
      final dynamic vehicle,
      final TransportSubtypeDTO? transportSubtype,
      final dynamic expressType}) = _$_ThreadDTO;
  const _ThreadDTO._() : super._();

  factory _ThreadDTO.fromJson(Map<String, dynamic> json) =
      _$_ThreadDTO.fromJson;

  @override
  String? get uid => throw _privateConstructorUsedError;
  @override
  String? get title => throw _privateConstructorUsedError;
  @override
  String? get number => throw _privateConstructorUsedError;
  @override
  String? get shortTitle => throw _privateConstructorUsedError;
  @override
  String? get threadMethodLink => throw _privateConstructorUsedError;
  @override
  dynamic get carrier => throw _privateConstructorUsedError;
  @override
  String? get transportType => throw _privateConstructorUsedError;
  @override
  dynamic get vehicle => throw _privateConstructorUsedError;
  @override
  TransportSubtypeDTO? get transportSubtype =>
      throw _privateConstructorUsedError;
  @override
  dynamic get expressType => throw _privateConstructorUsedError;
  @override
  @JsonKey(ignore: true)
  _$$_ThreadDTOCopyWith<_$_ThreadDTO> get copyWith =>
      throw _privateConstructorUsedError;
}
